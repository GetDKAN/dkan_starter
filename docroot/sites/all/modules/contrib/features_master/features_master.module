<?php

/**
 * Implements hook_features_api().
 */
function features_master_features_api() {
  return array(
    'features_master' => array(
      'name' => t('Master - Modules and Themes'),
      'default_hook' => 'features_master_defaults',
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'feature_source' => TRUE,
    ),
  );
}

/**
 * Implements hook_features_export_options().
 */
function features_master_features_export_options() {
  return array(
    'modules' => t('Enabled Modules'),
    // TODO: We need to get this working for themes.
    //'themes' => t('Enabled Themes'),
  );
}

/**
 * Implements hook_features_export().
 */
function features_master_features_export($data, &$export, $module_name = '') {
  $pipe = array();
  foreach ($data as $component_name) {
    if ($component_name == 'modules') {
      $export['features']['features_master']['modules'] = 'modules';
    }
    if ($component_name == 'themes') {
      $export['features']['features_master']['themes'] = 'themes';
    }
  }
 return $pipe;
}

function _features_master_get_modules($feature_module = NULL) {
  $modules = module_list();
   if (!empty($feature_module) && !in_array($feature_module, $modules)) {
    $modules[$feature_module] = $feature_module;
  }
  features_master_temporary_modules_alter($modules, 'export');
  asort($modules);
  return $modules;
}

function _features_master_get_themes($feature_module = NULL) {
  $themes = list_themes();
  //TODO: list_themes() actually retuns a lot of metadata, we shouldn't be storing.
  // Blocker: This blocks getting themes working.
  asort($themes);
  // TODO: ADD OR REMOVE DEFAULTS HERE
  return $themes;
}

/**
 * Implements hook_features_export_render().
 */
function features_master_features_export_render($module, $data, $export = NULL) {
  $code = array();
  $code[] = '  $features_master = array();';
  $code[] = '';
  foreach ($data as $name) {
     if ($name == 'modules') {
      $system_export = features_var_export(_features_master_get_modules(), '  ');
      $code[] = "  \$features_master['modules'] = {$system_export};";
     }
    if ($name == 'themes') {
      $system_export = features_var_export(_features_master_get_themes(), '  ');
      $code[] = "  \$features_master['themes'] = {$system_export};";
    }
  }
  $code[] = '';
  $code[] = '  return $features_master;';
  $code = implode("\n", $code);
  return array('features_master_defaults' => $code);
}

/**
 * Implements hook_features_revert().
 */
function features_master_features_revert($module) {
  $data = features_get_default('features_master', $module);
  features_master_temporary_modules_alter($data['modules'], 'revert');
  if (!empty($data['modules'])) {
    $current_enabled_modules = module_list();
    if ($enable_modules = array_diff_key($data['modules'], $current_enabled_modules)) {
      foreach ($enable_modules as $module) {
        // TODO: We could speed the process up by checking the database each time to see if a module was already enabled,
        // perhaps as a dependency of another module just installed.
        try {
          $success = module_enable(array($module));
        } catch (Exception $e) {
          $success = false;
          drupal_set_message(t('FEATURES MASTER: Enabling @module or one of it\'s dependencies caused an exception: @ex', array('@module' => $module, '@ex' => $e->getMessage())));
        }
        if (!$success) {
          // Consider these modules as not enabled;
          unset($enable_modules[$module]);
          drupal_set_message(t('FEATURES MASTER: @module has unmet dependencies, is not installed, or has some other issue and could not be enabled', array('@module' => $module)));
        }
      }

      if(empty($enable_modules)){
        drupal_set_message(t('FEATURES MASTER: No modules were enabled, either there was an error enabling them or none were set to enable.'));
      }
      else {
        $modules_string = implode(", ", $enable_modules);
        drupal_set_message(t('FEATURES MASTER: The following modules were enabled successfully: @modules_string', array('@modules_string' => $modules_string)));
      }
    }
    if ($disable_modules = array_diff_key($current_enabled_modules, $data['modules'])) {
      foreach ($disable_modules as $module) {
        // TODO: We don't get any return value from module_disable unfortunately. We should add a try catch here as well.
        module_disable(array($module));
      }
      $modules_string = implode(", ", $disable_modules);
      drupal_set_message(t('FEATURES MASTER: The following modules were disabled successfully: @modules_string', array('@modules_string' => $modules_string)));
    }

    //TODO: Implement the same thing for themes.
  }
}

/**
 * Alter the list of modules using variables.
 *
 * @param $modules
 * @param $mode
 *   Either 'revert' or 'export'. 'revert' will add/remove temporary modules. 'export' does the opposite.
 * @throws \Exception
 */
function features_master_temporary_modules_alter(&$modules, $mode) {
  // Handle temporary enabling and disabling of modules.
  if ($mode == 'revert') {
    $add_modules = variable_get('features_master_temp_enabled_modules', array());
    $rm_modules = variable_get('features_master_temp_disabled_modules', array());
  }
  // Reverse the adding and removing if in export mode.
  elseif ($mode == 'export') {
    $rm_modules = variable_get('features_master_temp_enabled_modules', array());
    $add_modules = variable_get('features_master_temp_disabled_modules', array());
  }
  else {
    throw new Exception("features_master_temporary_modules_alter: mode not recognized.");
  }

  foreach ($rm_modules as $module) {
    if (in_array($module, $modules)) {
      unset($modules[$module]);
    }
  }

  // Add the temporarily enabled modules
  foreach ($add_modules as $module) {
    if (!in_array($module, $modules)) {
      $modules[$module] = $module;
    }
  }
  //TODO: Maybe replace this with a drupal_alter so that other modules could effect this without the need for variables.
}
